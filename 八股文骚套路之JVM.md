**JVM 基础常见面试题汇总** ：

1. 运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】
    > 私有： 程序计数器、虚拟机栈、本地方法栈  
   > 共享：堆、方法区（运行时常量池）、直接内存

2. 说一下方法区和永久代的关系。【⭐⭐⭐】
    > 方法区是JVM的一种规范，永久代是Hotspot的实现

3. 讲一下 Java 创建一个对象的过程。【⭐⭐⭐⭐】
   > 类加载检查 -> 分配内存 -> 初始化零值 -> 设置对象头 -> 执行init方法  
   > [详细链接](https://javaguide.cn/java/jvm/memory-area/#:~:text=Step1%3A-,%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5,-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%81%87%E5%88%B0)

4. 对象的访问定位的两种方式（句柄和直接指针两种方式）。【⭐⭐⭐⭐⭐】
   > 句柄
   > >堆中划分出一块内存作为句柄池存放句柄，reference存句柄地址  
   > 句柄中存储对象实现数据和类型数据地址信息
   > 
   > 直接指针
   > > reference直接指向实例数据，对象实例中存储对象类型数据地址

5. 你了解分代理论吗？讲一下 Minor GC、还有 Full GC。【⭐⭐⭐⭐⭐】
   > 为更快回收内存和更快分配内存，把堆分为新生代和老年代  
   > minor gc发生在新生代，速度快，major gc发生在老年代，速度慢  
   > full gc是整个堆的GC，速度极慢，会引起全局停顿

6. Java 用什么方法确定哪些对象该被清理？ 讲一下可达性分析算法的流程。【⭐⭐⭐⭐】
   > 如何确定？
   > > 1、引用计数  
   > 2、可达性分析
   > 
   > 可达性分析算法
   > > 1、确定GC roots对象  
   > 2、从这些节点向下搜索，确定引用链  
   > 3、引用链之外的对象，不可达
   > 
   > 哪些对象可作为gc roots对象？
   > > 虚拟机栈(栈帧中的本地变量表)中引用的对象  
   本地方法栈(Native 方法)中引用的对象  
   方法区中类静态属性引用的对象  
   方法区中常量引用的对象  
   所有被同步锁持有的对象  

7. JDK 中有几种引用类型？分别的特点是什么？【⭐⭐】
   > 哪几种？
   > > 强、软、弱、虚
   > 
   > 特点？
   > > 强：无论如何不会被回收  
   > 软：内存足够时不回收，不足时回收  
   > 弱：gc会直接回收  
   > 虚：跟没有一样，随时会被回收，主要用于跟踪对象被gc的活动

8. 如何回收方法区？【⭐⭐⭐】
   >主要回收两类：废弃常量（运行时常量池）、废弃类（方法区）  
   > 注：字符串常量池从1.7被拿到了堆中，不在运行时常量池内  
   > 所以这个问题等同于问如何判断废弃常量和废弃类？
   > 
   > 废弃常量判断：
   > > 没有任何string对象引用该字符串常量的话，就是一个废弃常量
   > 
   > 废弃类判断：
   > > 1、不存在该类的任何实例对象  
   > 2、加载改类的classloader被回收  
   > 3、该类对应的class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

9. 标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】
   >标记清除
   > > 标记所有存活对象，完成标记后统一回收没有被标记的对象  
   > 标记与清除的效率不高，gc后产生大量空间碎片  
   > 
   > 标记复制
   > > 内存分为两块，每次只用其中一块  
   > 确定就是可用内存缩小了
   > 
   > 标记整理
   > > 标记所有存活对象，被标记对象往一端移动，清除边界外内存

10. JVM 中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】
   >安全点
   >>代码中一些特定位置，当线程运行到此处时状态是确定的，JVM可以安全地做一些操作，比如GC  
   > 方法返回前、调用方法后、抛出异常时、循环末尾等都是常见的安全点
   > 
   > 安全区
   >> 在一段代码片段中，引用关系不会发生变化。在这个区域任何地方开始gc都是安全的
   > 
   > 写屏障
   >> 对一个对象引用进行写操作之前或之后附加执行的逻辑，可以理解为引用赋值的aop切面   
   > 一个应用典范就是解决gc收集器“并发标记”阶段的 **对象消失** 问题

11. 并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？【⭐⭐⭐⭐】相关阅读：[面试官:你说你熟悉 jvm?那你讲一下并发的可达性分析](https://juejin.cn/post/6844904070788939790) 。
   > 解决什么问题？
   > > 减少STW时间（全局停顿）
   > 
   > 会面临什么问题？  
   > 浮动垃圾（本次gc无法清理）与对象消失
   >> 浮动垃圾?  
   > gc可达的对象在并发过程中因用户线程的操作实际已经不可达了，但此次gc并不会清理它  
   > 问题不大，下次gc清理即可  
   > --  
   >对象消失？   
   > gc标记不可达的对象因用户线程操作又变的可达，结果gc将其清理了  
   > 问题很严重
   >  
   > 如何解决？（此处可以扩展JVM的三色标记算法：黑（扫描完了所有引用的对象），白（未被扫描的对象），灰（正在扫描未扫描完其所有引用的对象））
   >> 1、增量更新（CMS） -- 用的写后屏障，记录了所有新增的引用关系  
   > 当黑色对象插入了新的白色对象引用关系时，记录，并发扫描结束后以这些黑色对象为根，重新扫描  
   > 2、原始快照（G1） -- 用的写前屏障，记录被删除的引用关系  
   > 灰色对象删除指向白色对象的引用时，这条引用记录会被记录，并发扫描结束后，会根据这些记录重新扫描一次  
   > **个人理解**：怎么说呢，相当于并发扫描阶段因为被删了，所以标记不到，但重新扫描的时候，根据记录的被删除的引用关系，
   > 最终还是扫描到了这个对象（即使这个对象真的是不可达的了，但为了容错，还是将其标记为可达），**相当于没删，所以才叫“快照”**

12. 对于 JVM 的垃圾收集器你有什么了解的？【⭐⭐⭐⭐】
   > 真问这么宽泛了，就自己说说有哪些收集器、用啥算法  
> 把重点往CMS上引吧

13. 新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】
   > 新生代
   > >serial 标记-复制 单线程  
   > ParNew 标记-复制 多线程（可以理解为serial的多线程版本）  
   > parallel scavenge 标记-复制 多线程，几乎与ParNew一样，关注点是CPU吞吐量
   > 
   > 老年代
   >> serial old 标记-整理 serial的老年代版本  
   > parallel old 标记-整理 parallel scavenge的老年版本  
   > cms 标记-清除 多线程  
   > g1  标记-整理（从局部看是标记-复制） 多线程  

14. java8默认的gc？
   > 使用 java -XX:+PrintCommandLineFlags -version 查看
   > ![默认gc](pic\java8默认gc.png)  
> 可以看到是parallel

15. 讲一下 CMS 垃圾收集器的四个步骤。CMS 有什么缺点？【⭐⭐⭐⭐】
   > 步骤
   >> 1、初始标记  
   > 暂停所有的其他线程，并记录下直接与 root 相连的对象  
   > 2、并发标记  
   >  同时开启 GC 和用户线程，用一个闭包结构去记录可达对象  
   > 3、重新标记（写后屏障、增量更新）  
   > 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录  
   > 4、并发清除  
   > 开启用户线程，同时 GC 线程
   > 
   > 缺点
   >> 1、CPU资源敏感  
   > 2、无法回收浮动垃圾（概念见11）  
   > 3、会产生空间碎片
   > 
   > 扩展
   >>并发标记都要面临的浮动垃圾和对象消失问题，详细看11

16. G1 垃圾收集器的步骤。有什么缺点？【⭐⭐⭐⭐】
   > 步骤
   >> 1、初始标记  
   > 暂停所有的其他线程，并记录下直接与 root 相连的对象  
   > 2、并发标记  
   >  同时开启 GC 和用户线程，用一个闭包结构去记录可达对象  
   > 3、重新标记（写前屏障、原始快照）    
   > 修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录  
   > 4、并发清除  
   > 开启用户线程，同时 GC 线程
   >
   > 缺点
   >> 1、CPU资源敏感  
   > 2、无法回收浮动垃圾（概念见11）  
   > 3、会产生空间碎片
   >
   > 扩展
   >>并发标记都要面临的浮动垃圾和对象消失问题，详细看11  

17. 讲一下内存分配策略？【⭐⭐⭐⭐】
   > 与对象创建第二步：分配内存有关  
   > 1、指针碰撞--内存规整的情况
   > > 只需要将内存分界指针朝未使用的内存区域偏移即可  
   > 
   > 2、空闲列表--内存不规整的情况  
   >>  虚拟机会维护可用的内存块列表，分配内存时找一块足够大的地儿分配出去，然后更新列表  
   > 
   > 内存分配并发问题解决
   >> 1、CAS+失败重试  
   > 2、TLAB -- 每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配  
   > 对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

18. 虚拟机基础故障处理工具有哪些？【⭐⭐⭐】
   > 就介绍jdk [bin目录下的一些自带工具](https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools/#:~:text=%23-,jps,-%3A%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%20Java)  
   > 
   > jps -- 查看所有 Java 进程，类似ps
   > 
   > jstat -- 监视虚拟机各种运行状态信息
   >> 比如 jstat -gc -h3 31736 1000 10表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部 
   > 
   > jinfo -- 实时查看和调整虚拟机各项参数
   >> 可以在不重启虚拟机的情况下动态修改jvm参数
   > 
   > jmap -- 生成堆转储快照，用于数据分析  
   > jhat -- 分析dump快照文件，会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果  
   > **jstack** -- 生成虚拟机当前时刻的线程快照，**可以查看到死锁** 
   > 
   > 扩展，一些可视化工具如 Jconsole、visual vm ，记个名字
   
19. 什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】
   > 字节码  
   >> 只面向虚拟机，JVM可以理解的代码
   > 
   > [类文件结构组成](https://javaguide.cn/java/jvm/class-file-structure/#:~:text=%E4%BA%8C-,Class%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93,-%E6%A0%B9%E6%8D%AE%20Java%20%E8%99%9A%E6%8B%9F)
   >> 只存在两种数据类型：无符号数和表  
   > 无符号数: 基本数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值  
   > 表:多个无符号数或其他表作为数据项构成的符合数据类型，所以表都习惯以_info结尾  
   >> 如图  
   >> ![类文件结构](pic\类文件结构.png)

20. 类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】
   >  生命周期
   >> 加载 - 验证 - 准备 - 解析 - 初始化（到此处也是类加载过程） -- 使用 -- 卸载
   > > ![类生命周期](pic\类生命周期.png) 
   > 
   > 加载过程  
   > 1、加载
   >>  ①通过类全限定名获取定义类的二进制字节流  
   > ②将字节流所代表的静态存储结构转换为方法区的运行时数据结构  
   > ③在内存中生成一个代表该类的class对象，作为方法区数据的访问入口
   > 
   > 2、验证  
   >>  确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，不会危害虚拟机安全
   > 
   > 3、准备
   >>  为类变量分配内存并设置类变量初始值，注意是类变量不是实例变量  
   > 通常类变量初始化为零值，如果加了final关键字，则直接初始化成定义的值  
   > 
   > 4、解析
   >>  将常量池中的符号引用替换为直接引用的过程（静态链接） ，得到类或者字段、方法在内存中的指针或者偏移量  
   > 有了直接引用，那引用的目标必定已经存在于内存中
   > 
   > 5、初始化  
   >>  执行类构造器<clinit>方法的过程
   > 
   > 哪几种情况必须初始化？
   >>  1、new（新建一个对象）、getstatic（访问静态变量，注意是静态变量非静态常量，常量直接到常量池里去了）
   > 、putstatic（给类静态变量赋值）、invokestatic（调用静态方法）  
   > 2、使用反射对类进行调用，必须先初始化类  
   > 3、初始化一个类，若其父类还未初始化，必须先初始化其父类  
   > 4、虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类  
   > 5、MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类  
   > 6、（JDK1.8新增）当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，
   > **如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化**

21. 讲一下双亲委派模型。【⭐⭐⭐⭐⭐】
   > 1、先了解内置的三个类加载器  
   > BootstrapClassLoader(启动类加载器)   
   > >最顶层，C++实现，负责加载 %JAVA_HOME%/lib目录下的 jar 包和类  
   > 或被 -Xbootclasspath参数指定的路径中的所有类 
   > 
   > ExtensionClassLoader(扩展类加载器) 
   > >负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类  
   > 或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。   
   > 
   > AppClassLoader(应用程序类加载器) 
   > >加载当前应用 classpath 下的所有 jar 包和类
   > 
   > 2、双亲委派
   >>  加载类时，首先会把该请求委派给父类加载器的 loadClass() 处理  
   > 当父类加载器无法处理时，才由自己来处理
   > 
   > 3、为什么要双亲委派？
   >>  可以避免类的重复加载，保证核心API不被篡改
   > 
   > 4、如何打破双亲委派？[这篇文章排版比较舒服](https://www.jianshu.com/p/22d9c0a2d2e9)
   >>  ①SPI机制直接绕开loadclass方法，当前线程设定关联类加载器  
   > ②自定义类加载器，重写loadclass方法。  
   > PS:类加载器只能加载class文件

