### 救急准备

下面的知识点都是要看的，我通过打星与加粗的方式对知识点的重要性进行评级！难度是针对互联网大厂的。

- ⭐ ：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。
- ⭐⭐ ：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。
- ⭐⭐⭐：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。
- ⭐⭐⭐⭐：面试高频考点。
- ⭐⭐⭐⭐⭐：面试超高频考点。四星考点和五星考点是参加十场面试，至少能有五场面试问到这些的。大家在准备面试过程中尽量把这些知识点的回答条理梳理清楚，面试官一问就开背。

**Java 并发常见面试题汇总** ：

1. 进程和线程的区别。【⭐⭐⭐⭐⭐】什么是线程什么是进程，线程和进程各自的`运行状态`、线程的`通信方式`和进程的`通信方式`。
    > 进程：系统资源调度的最小单元，一个程序的启动到停止的过程就是一个进程的产生到消亡的过程  
   >> 运行状态：就绪态（未获得CPU时间片）、阻塞态（IO阻塞、事件发生等）、运行态（获得CPU时间片）   
   > 进程间通信：管道pipe、命名管道namepipe、信号量、信号、消息队列、共享内存、套接字socket
   > 
   > 线程：CPU资源调度的最小单位，一个进程内部有多个线程 
   >> 运行状态： NEW -> RUNABLE(READY,RUNNING) -> WAITING/TIMED_WATING/BLOCKED -> TERMINATED  
   > 线程间通信：锁、信号量、信号

2. 创建线程的方式。【⭐⭐⭐⭐】不仅要把创建线程的方式记熟、记住各种方式的优缺点，还要能写出代码来。有的面试官是会让你写代码创建两个线程然后执行一些操作的，比如两个线程交替输出数字。
    > 四种创建方式  
   继承Thread类，覆盖run方法，调用 Thread#start启动  
   实现Runnable接口，创建实例，作为Thread构造参数传入，调用 Thread#start启动  
   实现Callable接口，创建实例，作为FutureTask<>构造参数创建FutureTask对象，将FutureTask对象作为Thread构造参数传入，调用 Thread#start启动  
   ExecutorService创建一个线程池
   
3. 如何保证线程的顺序执行？
    > 两种方式  
   > 1、若是手动创建的线程，则每个线程start后再join，即可保证顺序  
   > 2、可以创建一个最大线程数量为1,带阻塞队列的线程池依次submit，也可以做到顺序
4. 什么是死锁，死锁如何产生，死锁如何避免。【⭐⭐⭐⭐⭐】
    > 什么是死锁？  
   > > 多个线程同时被堵塞，都在等待共同的资源且资源无法被释放，造成线程无限期堵塞，程序无法正常终止  
   > 
   > 死锁如何产生？（死锁的具备条件）  
   > > 1、互斥：一个资源任一时刻只能由一个线程占用  
   > 2、请求保持：线程因请求资源而阻塞时，对已获得的资源保持不放   
   > 3、不剥夺：线程已获得的资源在未使用完之前不能被其他线程强行剥夺  
   > 4、 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系
   > 
   > 如何避免死锁？
   > > 1、破坏请求保持条件：一次性请求所有资源，不分批  
   > 2、破坏不剥夺：占用资源的线程请求资源请求不到时，主动释放已占用资源  
   > 3、破坏循环等待：按序申请资源，释放资源则反序释放

5. 并发编程的三大特性（原子性、可见性以及有序性）。【⭐⭐⭐⭐】
   > 原子性：一批操作，要么全都执行不会被中断，要么全部不执行。（synchronized保证代码片段原子性）  
   > 可见性：一个线程对共享变量进行了修改，另外的线程可以看到修改后的最新值 （volatile保证变量可见）  
   > 有序性：JVM指令重排，代码的执行顺序未必就是编写代码时候的顺序 （volatile保证有序），小扩展，as-if-serial语义，后面有说  

6. `synchronized`原理？
   > 1、首先了解一个概念：JAVA对象头  
   > > 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充  
   > ![](pic\java对象头.png)  
   > JAVA对象头的主要组成部分是 Mark Word 和 Class Metadata Adress
   > 
   > 2、Mark Word
   > > 存储对象自身的运行时数据，内容并不固定，默认情况下存的是hashcode、gc分代年龄等  
   > 
   > 3、原理  
   > > 不论作用于方法，还是代码块，本质上都是对对象监视器monitor对象的获取，获取的过程
   > 对应锁升级的过程，也是Mark Word中数据存储变更的过程，具体升级流程见下  
   > 作用于方法：ACC_SYNCHRONIZED 标识同步方法  
   > 作用于代码块：monitorenter 和 monitorexit

7. `synchronized` 锁升级流程。【⭐⭐⭐⭐⭐】
   > 无锁 -> 偏向锁 -> 轻量锁 -> 重量锁

8. `volatile` 关键字。【⭐⭐⭐⭐⭐】对比和 `synchronized` 的区别。
   > volatile
   > > 保证变量可见性，但不保证操作的原子性（结合JMM讲为什么可见），禁止指令重排
   > 
   > 对比：  
   > >1.作用对象 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块  
   > 2.volatile 保证数据可见性，不保证原子性。synchronized 关键字两者都能保证  
   > 3.目的不一样 volatile目的是数据可见，synchronized目的是线程间资源同步

9. `JMM`（Java Memory Model，Java 内存模型）和 `happens-before` 原则。【⭐⭐⭐⭐⭐】面试中重点！几乎必问。
   > JMM
   > > 变量都存储在主内存中。每个线程还有自己的工作内存,工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）
   > 都必须在工作内存中进行，而不能直接读写主内存中的变量  
   > 
   > happens-before
   > > 不同线程间的操作，只要操作a在操作b之前发生，那JMM将保证a操作对b可见  
   >     ![](pic\happens-before.png)


9. as-if-serial语义
   > 指不论如何重排序，程序执行结果不能变。比如 C = A + B ,那么指令重排时C的赋值语句不能排到AB的前面  

10. `ThreadLocal`。【⭐⭐⭐⭐】
   > 

11. 线程池。【⭐⭐⭐⭐⭐】超高频考点。需要答出线程池有哪几种，各种线程池的优缺点，线程池的重要参数、线程池的`执行流程`、线程池的饱和策略、如何设置线程池的大小等等。这里也能背十几分钟。
   > 

12. `ReentrantLock` 和 `AQS`。【⭐⭐⭐⭐⭐】
   > 

13. 乐观锁和悲观锁的区别。【⭐⭐⭐⭐⭐】
   > 乐观锁  
   >> 认为冲突不会发生，获取数据时不添加锁，只在更新时判断数据是否被更改过，
   > 根据判断结果采取不同措施（如cas算法）  
   > 适用读多写少的场景
   > 
   >悲观锁
   >> 认为冲突一定会发生，因此获取数据添加锁（synchronized、Lock）  
   > 适用写多读少的场景

14. `CAS` 了解么？原理？什么是 ABA 问题？ABA 问题怎么解决？很多地方都用到了 `CAS` 比如 `ConcurrentHashMap` 采用 `CAS` 和 `synchronized` 来保证并发安全，再比如`java.util.concurrent.atomic`包中的类通过 `volatile+CAS` 重试保证线程安全性。和面试官聊 `CAS` 的时候，你可以结合 `CAS` 的一些实际应用来说。
   > cas
   >> "比较-替换"，将要修改的值与预期的值比较，相等则将其修改为新的值  
   >   简单说就是：我在更新一个值的时候，认为这个值在我更新前应该是a，比较发现确实是a，那我就认为期间没有冲突发生，于是我更新
   > 
   > aba问题
   >> 线程1要更新值a，a在此期间被线程2更新成了b，又从b变成了a，线程1cas比较a发现相等，于是认为期间没有冲突发生，实际上这个变量已经被其它线程动过了  
   > 
   > 如何解决ABA？
   >> 给变量加版本号/时间戳/标识等，比如 AtomicStampedReference

15. `Atomic` 原子类【⭐⭐】